This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-06T14:55:50.706Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
Builders/
  BlockBuilders/
    ActionBlockBuilder.cs
    BlockBaseBuilder.cs
    ContextBlockBuilder.cs
    DividerBlockBuilder.cs
    FileBlockBuilder.cs
    HeaderBlockBuilder.cs
    ImageBlockBuilder.cs
    InputBlockBuilder.cs
    RichTextBlockBuilder.cs
    SectionBlockBuilder.cs
    SlackWebhookPayloadBuilder.cs
    VideoBlockBuilder.cs
  BlockElementBuilders/
    BlockElementBaseBuilder.cs
    ButtonBlockElementBuilder.cs
    ImageBlockElementBuilder.cs
    MultiSelectMenuBlockElementBuilder.cs
  ConfirmationDialogObjectBuilder.cs
  TextObjectBuilder.cs
Enums/
  BlockElementType.cs
  BlockType.cs
  RichTextBlockElementType.cs
  RichTextElementType.cs
  RichTextListStyleType.cs
  TextObjectType.cs
  ViewObjectType.cs
  WorkflowButtonElementStyle.cs
JsonConverters/
  ActionBlockConverter.cs
Models/
  BlockElements/
    BlockElementBase.cs
    ButtonElement.cs
    CheckboxElement.cs
    DatePickerElement.cs
    DateTimePickerElement.cs
    EmailInputElement.cs
    FileInputElement.cs
    ImageElement.cs
    MultiSelectMenuElement.cs
    NumberInputElement.cs
    OverflowMenuElement.cs
    PlainTextInputElement.cs
    RadioButtonGroupElement.cs
    RichTextInputElement.cs
    SelectMenuElement.cs
    TimePickerElement.cs
    UrlInputElement.cs
    WorkflowButtonElement.cs
  Blocks/
    ActionBlock.cs
    BlockBase.cs
    ContextBlock.cs
    DividerBlock.cs
    FileBlock.cs
    HeaderBlock.cs
    ImageBlock.cs
    InputBlock.cs
    RichTextBlock.cs
    SectionBlock.cs
    VideoBlock.cs
  CompositionObjects/
    ConfirmationDialogObject.cs
    ConversationFilterObject.cs
    DispatchActionConfigurationObject.cs
    OptionGroupObject.cs
    OptionObject.cs
    SlackFileObject.cs
    TextObject.cs
    TriggerObject.cs
    WorkflowObject.cs
  RichTextElements/
    AdvancedTextStyle.cs
    BasicTextStyle.cs
    BroadcastElement.cs
    ChannelElement.cs
    ColorElement.cs
    DateElement.cs
    EmojiElement.cs
    LinkElement.cs
    TextElement.cs
    UserElement.cs
    UserGroupElement.cs
  ViewObjects/
    HomeTab.cs
    Modal.cs
  SlackWebhookPayload.cs

================================================================
Repository Files
================================================================

================
File: Builders/BlockBuilders/ActionBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Builders;

public class ActionBlockBuilder : BlockBaseBuilder
{
     private readonly List<IActionBlockElement> _elements = new();

     public ActionBlockBuilder AddElement<T>(Func<T> elementFactory) where T : IActionBlockElement
     {
          _elements.Add(elementFactory());
          return this;
     }
     
     public override ActionBlock Build()
     {
          if (_elements is null)
               throw new InvalidOperationException("Elements are required");
          
          return new ActionBlock
          {
               BlockId = base.Build().BlockId,
               Elements = _elements
          };
     }
}

================
File: Builders/BlockBuilders/BlockBaseBuilder.cs
================
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Builders;

public class BlockBaseBuilder
{
    private string? _blockId;

    public BlockBaseBuilder WithBlockId(string blockId)
    {
        _blockId = blockId;
        return this;
    }

    public virtual BlockBase Build()
    {
        return new BlockBase
        {
            BlockId = _blockId
        };
    }
}

================
File: Builders/BlockBuilders/ContextBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Builders;

public class ContextBlockBuilder : BlockBaseBuilder
{
    private readonly List<IContextBlockElement> _elements = new();

    public ContextBlockBuilder AddElement<T>(Func<T> elementFactory) where T : IContextBlockElement
    {
        _elements.Add(elementFactory());
        return this;
    }

    public override BlockBase Build()
    {
        if (_elements.Count == 0)
            throw new InvalidOperationException("At least one element is required for an ActionBlock.");

        return new ContextBlock
        {
            BlockId = base.Build().BlockId,
            Elements = _elements
        };
    }
}

================
File: Builders/BlockBuilders/DividerBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Builders;

public class DividerBlockBuilder : BlockBaseBuilder
{
    public override BlockBase Build()
    {
        return new DividerBlock
        {
            BlockId = base.Build().BlockId
        };
    }
}

================
File: Builders/BlockBuilders/FileBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Builders;

public class FileBlockBuilder : BlockBaseBuilder
{
    private string _externalId = default!;
    private string _source = default!;
    
    public FileBlockBuilder WithExternalId(string externalId)
    {
        _externalId = externalId;
        return this;
    }
    
    public FileBlockBuilder WithSource(string source)
    {
        _source = source;
        return this;
    }
    
    public override BlockBase Build()
    {
        return new FileBlock
        {
            BlockId = base.Build().BlockId,
            ExternalId = _externalId,
            Source = _source
        };
    }
}

================
File: Builders/BlockBuilders/HeaderBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders;

public class HeaderBlockBuilder : BlockBaseBuilder
{
    private TextObject? _text;

    public HeaderBlockBuilder WithText(TextObject text)
    {
        _text = text;
        return this;
    }

    public override HeaderBlock Build()
    {
        if (_text is null)
            throw new InvalidOperationException("Text is required");
        
        return new HeaderBlock
        {
            BlockId = base.Build().BlockId,
            Text = _text
        };
    }
}

================
File: Builders/BlockBuilders/ImageBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders;

public class ImageBlockBuilder : BlockBaseBuilder
{
    private TextObject? _altText;
    private string? _imageUrl;
    private SlackFileObject? _slackFile;
    private TextObject? _title;

    public ImageBlockBuilder WithAltText(TextObject altText)
    {
        _altText = altText;
        return this;
    }

    public ImageBlockBuilder WithImageUrl(string imageUrl)
    {
        _imageUrl = imageUrl;
        return this;
    }

    public ImageBlockBuilder WithSlackFile(SlackFileObject slackFile)
    {
        _slackFile = slackFile;
        return this;
    }

    public ImageBlockBuilder WithTitle(TextObject title)
    {
        _title = title;
        return this;
    }

    public override ImageBlock Build()
    {
        if (_altText is null)
            throw new InvalidOperationException("AltText is required");

        if (_imageUrl is null && _slackFile is null)
            throw new InvalidOperationException("Either ImageUrl or SlackUrl need to be provided");
        
        return new ImageBlock
        {
            BlockId = base.Build().BlockId,
            AltText = _altText,
            ImageUrl = _imageUrl,
            SlackFile = _slackFile,
            Title = _title,
        };
    }
}

================
File: Builders/BlockBuilders/InputBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders;

public class InputBlockBuilder : BlockBaseBuilder
{
    private TextObject? _label;
    private IInputBlockElement? _element;
    private bool? _dispatchAction;
    private TextObject? _hint;
    private bool? _optional;
    
    public InputBlockBuilder WithLabel(TextObject label)
    {
        _label = label;
        return this;
    }
    
    public InputBlockBuilder WithElement<T>(Func<T> elementFactory) where T : IInputBlockElement
    {
        _element = elementFactory();
        return this;
    }
    
    public InputBlockBuilder WithDispatchAction(bool dispatchAction)
    {
        _dispatchAction = dispatchAction;
        return this;
    }
    
    public InputBlockBuilder WithHint(TextObject hint)
    {
        _hint = hint;
        return this;
    }
    
    public InputBlockBuilder WithOptional(bool optional)
    {
        _optional = optional;
        return this;
    }
    
    public override InputBlock Build()
    {
        if (_label is null)
            throw new InvalidOperationException("Label must have a value");

        if (_element is null)
            throw new InvalidOperationException("Element must have a value");
        
        return new InputBlock
        {
            BlockId = base.Build().BlockId,
            Label = _label,
            Element = _element,
            DispatchAction = _dispatchAction,
            Hint = _hint,
            Optional = _optional
        };
    }
}

================
File: Builders/BlockBuilders/RichTextBlockBuilder.cs
================
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Builders;

public class RichTextBlockBuilder : BlockBaseBuilder
{
    private readonly List<IRichTextBlockElement> _elements = new();

    public RichTextBlockBuilder AddElement<T>(Func<T> elementFactory) where T : IRichTextBlockElement
    {
        _elements.Add(elementFactory());
        return this;
    }

    public override BlockBase Build()
    {
        if (_elements.Count == 0)
            throw new InvalidOperationException("At least one element is required for a RichTextBlock.");

        return new RichTextBlock
        {
            BlockId = base.Build().BlockId,
            Elements = _elements
        };
    }
}

public class RichTextElementsBuilder
{
    private readonly List<IRichTextBlockElement> _elements = new();

    public RichTextElementsBuilder AddSection(Action<RichTextSectionBuilder> buildAction)
    {
        var builder = new RichTextSectionBuilder();
        buildAction(builder);
        _elements.Add(builder.Build());
        return this;
    }

    public RichTextElementsBuilder AddList(Action<RichTextListBuilder> buildAction)
    {
        var builder = new RichTextListBuilder();
        buildAction(builder);
        _elements.Add(builder.Build());
        return this;
    }

    public RichTextElementsBuilder AddPreformatted(Action<RichTextPreformattedBuilder> buildAction)
    {
        var builder = new RichTextPreformattedBuilder();
        buildAction(builder);
        _elements.Add(builder.Build());
        return this;
    }

    public RichTextElementsBuilder AddQuote(Action<RichTextQuoteBuilder> buildAction)
    {
        var builder = new RichTextQuoteBuilder();
        buildAction(builder);
        _elements.Add(builder.Build());
        return this;
    }

    public IEnumerable<IRichTextBlockElement> Build() => _elements;
}

public class RichTextSectionBuilder
{
    private readonly List<IRichTextElement> _elements = new();

    public RichTextSectionBuilder AddElement(IRichTextElement element)
    {
        _elements.Add(element);
        return this;
    }

    public RichTextSection Build()
    {
        if (_elements.Count == 0)
            throw new InvalidOperationException("At least one element is required for a RichTextSection.");

        return new RichTextSection
        {
            Elements = _elements.ToArray()
        };
    }
}

public class RichTextListBuilder
{
    private RichTextListStyleType _style;
    private readonly List<IRichTextElement> _elements = new();
    private int? _indent;
    private int? _offset;
    private int? _border;

    public RichTextListBuilder WithStyle(RichTextListStyleType style)
    {
        _style = style;
        return this;
    }

    public RichTextListBuilder AddElement(IRichTextElement element)
    {
        _elements.Add(element);
        return this;
    }

    public RichTextListBuilder WithIndent(int indent)
    {
        _indent = indent;
        return this;
    }

    public RichTextListBuilder WithOffset(int offset)
    {
        _offset = offset;
        return this;
    }

    public RichTextListBuilder WithBorder(int border)
    {
        _border = border;
        return this;
    }

    public RichTextList Build()
    {
        if (_elements.Count == 0)
            throw new InvalidOperationException("At least one element is required for a RichTextList.");

        return new RichTextList
        {
            Style = _style,
            Elements = _elements.ToArray(),
            Indent = _indent,
            Offset = _offset,
            Border = _border
        };
    }
}

public class RichTextPreformattedBuilder
{
    private readonly List<IRichTextElement> _elements = new();
    private int? _border;

    public RichTextPreformattedBuilder AddElement(IRichTextElement element)
    {
        _elements.Add(element);
        return this;
    }

    public RichTextPreformattedBuilder WithBorder(int border)
    {
        _border = border;
        return this;
    }

    public RichTextPreformatted Build()
    {
        if (_elements.Count == 0)
            throw new InvalidOperationException("At least one element is required for a RichTextPreformatted.");

        return new RichTextPreformatted
        {
            Elements = _elements.ToArray(),
            Border = _border
        };
    }
}

public class RichTextQuoteBuilder
{
    private readonly List<IRichTextElement> _elements = new();
    private int? _border;

    public RichTextQuoteBuilder AddElement(IRichTextElement element)
    {
        _elements.Add(element);
        return this;
    }

    public RichTextQuoteBuilder WithBorder(int border)
    {
        _border = border;
        return this;
    }

    public RichTextQuote Build()
    {
        if (_elements.Count == 0)
            throw new InvalidOperationException("At least one element is required for a RichTextQuote.");

        return new RichTextQuote
        {
            Elements = _elements.ToArray(),
            Border = _border
        };
    }
}

================
File: Builders/BlockBuilders/SectionBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders;

public class SectionBlockBuilder : BlockBaseBuilder
{
    private TextObject? _text;
    private List<TextObject>? _fields;
    private ISectionBlockElement? _accessory;
    private bool? _expand;

    public SectionBlockBuilder WithText(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _text = builder.Build();
        return this;
    }

    public SectionBlockBuilder AddField(Action<TextObjectBuilder> buildAction)
    {
        _fields ??= new List<TextObject>();
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _fields.Add(builder.Build());
        return this;
    }

    public SectionBlockBuilder WithAccessory<T>(Func<T> accessoryFactory) where T : ISectionBlockElement
    {
        _accessory = accessoryFactory();
        return this;
    }

    public SectionBlockBuilder WithExpand(bool expand)
    {
        _expand = expand;
        return this;
    }

    public override BlockBase Build()
    {
        if (_text == null && (_fields == null || _fields.Count == 0))
            throw new InvalidOperationException("Either text or at least one field is required for a SectionBlock.");

        return new SectionBlock
        {
            BlockId = base.Build().BlockId,
            Text = _text,
            Fields = _fields?.ToArray(),
            Accessory = _accessory,
            Expand = _expand
        };
    }
}

================
File: Builders/BlockBuilders/SlackWebhookPayloadBuilder.cs
================
using Hooki.Slack.Models;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Builders;

public class SlackWebhookPayloadBuilder
{
    private readonly List<BlockBase> _blocks = new();

    public SlackWebhookPayloadBuilder AddBlock<T>(Action<T> buildAction) where T : BlockBaseBuilder, new()
    {
        var builder = new T();
        buildAction(builder);
        _blocks.Add(builder.Build());
        return this;
    }

    public SlackWebhookPayload Build()
    {
        if (_blocks.Count == 0)
            throw new InvalidOperationException("At least one block is required.");

        return new SlackWebhookPayload
        {
            Blocks = _blocks
        };
    }
}

================
File: Builders/BlockBuilders/VideoBlockBuilder.cs
================
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;
using Hooki.Slack.Enums;

namespace Hooki.Slack.Builders;

public class VideoBlockBuilder : BlockBaseBuilder
{
    private string? _altText;
    private string? _authorName;
    private TextObject? _description;
    private string? _providerIconUrl;
    private string? _providerName;
    private TextObject? _title;
    private string? _titleUrl;
    private string? _thumbnailUrl;
    private string? _videoUrl;

    public VideoBlockBuilder WithAltText(string altText)
    {
        _altText = altText;
        return this;
    }

    public VideoBlockBuilder WithAuthorName(string authorName)
    {
        _authorName = authorName;
        return this;
    }

    public VideoBlockBuilder WithDescription(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _description = builder.Build();
        return this;
    }

    public VideoBlockBuilder WithProviderIconUrl(string providerIconUrl)
    {
        _providerIconUrl = providerIconUrl;
        return this;
    }

    public VideoBlockBuilder WithProviderName(string providerName)
    {
        _providerName = providerName;
        return this;
    }

    public VideoBlockBuilder WithTitle(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _title = builder.Build();
        return this;
    }

    public VideoBlockBuilder WithTitleUrl(string titleUrl)
    {
        if (!titleUrl.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
            throw new ArgumentException("Title URL must start with 'https://'", nameof(titleUrl));

        _titleUrl = titleUrl;
        return this;
    }

    public VideoBlockBuilder WithThumbnailUrl(string thumbnailUrl)
    {
        _thumbnailUrl = thumbnailUrl;
        return this;
    }

    public VideoBlockBuilder WithVideoUrl(string videoUrl)
    {
        _videoUrl = videoUrl;
        return this;
    }

    public override BlockBase Build()
    {
        if (string.IsNullOrWhiteSpace(_altText))
            throw new InvalidOperationException("AltText is required for a VideoBlock.");

        if (_description == null)
            throw new InvalidOperationException("Description is required for a VideoBlock.");

        if (_description.Type != TextObjectType.PlainText)
            throw new InvalidOperationException("Description must be of type PlainText.");

        if (_title != null && _title.Type != TextObjectType.PlainText)
            throw new InvalidOperationException("Title must be of type PlainText.");

        if (string.IsNullOrWhiteSpace(_thumbnailUrl))
            throw new InvalidOperationException("ThumbnailUrl is required for a VideoBlock.");

        if (string.IsNullOrWhiteSpace(_videoUrl))
            throw new InvalidOperationException("VideoUrl is required for a VideoBlock.");

        return new VideoBlock
        {
            BlockId = base.Build().BlockId,
            AltText = _altText,
            AuthorName = _authorName,
            Description = _description,
            ProviderIconUrl = _providerIconUrl,
            ProviderName = _providerName,
            Title = _title,
            TitleUrl = _titleUrl,
            ThumbnailUrl = _thumbnailUrl,
            VideoUrl = _videoUrl
        };
    }
}

================
File: Builders/BlockElementBuilders/BlockElementBaseBuilder.cs
================
using Hooki.Slack.Models.BlockElements;

namespace Hooki.Slack.Builders.BlockElementBuilders;


public class BlockElementBaseBuilder
{
    private string? _actionId;

    public BlockElementBaseBuilder WithActionId(string actionId)
    {
        _actionId = actionId;
        return this;
    }

    public virtual BlockElementBase Build()
    {
        return new BlockElementBase
        {
            ActionId = _actionId
        };
    }
}

================
File: Builders/BlockElementBuilders/ButtonBlockElementBuilder.cs
================
using Hooki.Slack.Models.BlockElements;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders.BlockElementBuilders;

public class ButtonElementBuilder : BlockElementBaseBuilder
{
    private TextObject? _text;
    private string? _url;
    private string? _value;
    private string? _style;
    private ConfirmationDialogObject? _confirm;
    private string? _accessibilityLabel;

    public ButtonElementBuilder WithText(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _text = builder.Build();
        return this;
    }

    public ButtonElementBuilder WithUrl(string url)
    {
        _url = url;
        return this;
    }

    public ButtonElementBuilder WithValue(string value)
    {
        _value = value;
        return this;
    }

    public ButtonElementBuilder WithStyle(string style)
    {
        _style = style;
        return this;
    }

    public ButtonElementBuilder WithConfirm(Action<ConfirmationDialogObjectBuilder> buildAction)
    {
        var builder = new ConfirmationDialogObjectBuilder();
        buildAction(builder);
        _confirm = builder.Build();
        return this;
    }

    public ButtonElementBuilder WithAccessibilityLabel(string accessibilityLabel)
    {
        _accessibilityLabel = accessibilityLabel;
        return this;
    }

    public override BlockElementBase Build()
    {
        if (_text == null)
            throw new InvalidOperationException("Text is required for a ButtonElement.");

        return new ButtonElement
        {
            ActionId = base.Build().ActionId,
            Text = _text,
            Url = _url,
            Value = _value,
            Style = _style,
            Confirm = _confirm,
            AccessibilityLabel = _accessibilityLabel
        };
    }
}

================
File: Builders/BlockElementBuilders/ImageBlockElementBuilder.cs
================
using Hooki.Slack.Models.BlockElements;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders.BlockElementBuilders;

public class ImageBlockElementBuilder: BlockElementBaseBuilder
{
    private string? _altText;
    private string? _imageUrl;
    private SlackFileObject? _slackFile;

    public ImageBlockElementBuilder WithAltText(string altText)
    {
        _altText = altText;
        return this;
    }

    public ImageBlockElementBuilder WithImageUrl(string imageUrl)
    {
        if (imageUrl.Length > 3000)
            throw new ArgumentException("ImageUrl must not exceed 3000 characters.", nameof(imageUrl));

        _imageUrl = imageUrl;
        return this;
    }

    public ImageBlockElementBuilder WithSlackFile(SlackFileObject slackFile)
    {
        _slackFile = slackFile;
        return this;
    }

    public override BlockElementBase Build()
    {
        if (string.IsNullOrWhiteSpace(_altText))
            throw new InvalidOperationException("AltText is required for an ImageElement.");

        if (_imageUrl == null && _slackFile == null)
            throw new InvalidOperationException("Either ImageUrl or SlackFile must be provided for an ImageElement.");

        if (_imageUrl != null && _slackFile != null)
            throw new InvalidOperationException("Only one of ImageUrl or SlackFile can be provided for an ImageElement.");

        return new ImageElement
        {
            ActionId = base.Build().ActionId,
            AltText = _altText,
            ImageUrl = _imageUrl,
            SlackFile = _slackFile
        };
    }
}

================
File: Builders/BlockElementBuilders/MultiSelectMenuBlockElementBuilder.cs
================
using Hooki.Slack.Models.BlockElements;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders.BlockElementBuilders;

public class MultiSelectMenuBlockElementBuilder
{
    private TextObject? _placeholder;
    private readonly List<OptionObject> _options = [];
    private readonly List<OptionObject> _initialOptions = [];
    private readonly List<OptionGroupObject> _optionGroups = [];
    private ConfirmationDialogObject? _confirm;
    private bool? _focusOnLoad;
    private int? _maxSelectedItems;
    private string? _actionId;

    public MultiSelectMenuBlockElementBuilder WithActionId(string actionId)
    {
        _actionId = actionId;
        return this;
    }

    public MultiSelectMenuBlockElementBuilder WithPlaceholder(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _placeholder = builder.Build();
        return this;
    }

    public MultiSelectMenuBlockElementBuilder AddOption(OptionObject option)
    {
        _options.Add(option);
        return this;
    }

    public MultiSelectMenuBlockElementBuilder AddInitialOption(OptionObject option)
    {
        _initialOptions.Add(option);
        return this;
    }

    public MultiSelectMenuBlockElementBuilder AddOptionGroup(OptionGroupObject optionGroup)
    {
        _optionGroups.Add(optionGroup);
        return this;
    }

    public MultiSelectMenuBlockElementBuilder WithConfirm(ConfirmationDialogObject confirmation)
    {
        _confirm = confirmation;
        return this;
    }

    public MultiSelectMenuBlockElementBuilder WithFocusOnLoad(bool focusOnLoad)
    {
        _focusOnLoad = focusOnLoad;
        return this;
    }

    public MultiSelectMenuBlockElementBuilder WithMaxSelectedItems(int maxSelectedItems)
    {
        _maxSelectedItems = maxSelectedItems;
        return this;
    }

    public IActionBlockElement Build()
    {
        if (_options.Count == 0 && _optionGroups.Count == 0)
            throw new InvalidOperationException("Either options or option groups must be provided for a MultiSelectMenuElement.");

        return new MultiSelectMenuElement
        {
            ActionId = _actionId,
            Placeholder = _placeholder,
            Options = _options.Count > 0 ? _options.ToArray() : null,
            InitialOptions = _initialOptions.Count > 0 ? _initialOptions.ToArray() : null,
            OptionGroups = _optionGroups.Count > 0 ? _optionGroups.ToArray() : null,
            Confirm = _confirm,
            FocusOnLoad = _focusOnLoad,
            MaxSelectedItems = _maxSelectedItems
        };
    }
}

================
File: Builders/ConfirmationDialogObjectBuilder.cs
================
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders;

public class ConfirmationDialogObjectBuilder
{
    private TextObject? _title;
    private TextObject? _text;
    private TextObject? _confirm;
    private TextObject? _deny;
    private string? _style;

    public ConfirmationDialogObjectBuilder WithTitle(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _title = builder.Build();
        return this;
    }

    public ConfirmationDialogObjectBuilder WithText(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _text = builder.Build();
        return this;
    }

    public ConfirmationDialogObjectBuilder WithConfirm(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _confirm = builder.Build();
        return this;
    }

    public ConfirmationDialogObjectBuilder WithDeny(Action<TextObjectBuilder> buildAction)
    {
        var builder = new TextObjectBuilder();
        buildAction(builder);
        _deny = builder.Build();
        return this;
    }

    public ConfirmationDialogObjectBuilder WithStyle(string style)
    {
        _style = style;
        return this;
    }

    public ConfirmationDialogObject Build()
    {
        if (_title == null)
            throw new InvalidOperationException("Title is required for a ConfirmationDialogObject.");
        if (_text == null)
            throw new InvalidOperationException("Text is required for a ConfirmationDialogObject.");
        if (_confirm == null)
            throw new InvalidOperationException("Confirm is required for a ConfirmationDialogObject.");
        if (_deny == null)
            throw new InvalidOperationException("Deny is required for a ConfirmationDialogObject.");

        return new ConfirmationDialogObject
        {
            Title = _title,
            Text = _text,
            Confirm = _confirm,
            Deny = _deny,
            Style = _style
        };
    }
}

================
File: Builders/TextObjectBuilder.cs
================
using Hooki.Slack.Enums;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Builders;

public class TextObjectBuilder
{
    private TextObjectType? _type;
    private string? _text;
    private bool? _emoji;
    private bool? _verbatim;

    public TextObjectBuilder WithType(TextObjectType type)
    {
        _type = type;
        return this;
    }

    public TextObjectBuilder WithText(string text)
    {
        _text = text;
        return this;
    }

    public TextObjectBuilder WithEmoji(bool emoji)
    {
        _emoji = emoji;
        return this;
    }

    public TextObjectBuilder WithVerbatim(bool verbatim)
    {
        _verbatim = verbatim;
        return this;
    }

    public TextObject Build()
    {
        if (_type == null)
            throw new InvalidOperationException("Type is required for a TextObject.");

        if (string.IsNullOrWhiteSpace(_text))
            throw new InvalidOperationException("Text is required for a TextObject.");

        if (_type == TextObjectType.Markdown && _emoji.HasValue)
            throw new InvalidOperationException("Emoji can only be set when Type is PlainText.");

        if (_type == TextObjectType.PlainText && _verbatim.HasValue)
            throw new InvalidOperationException("Verbatim can only be set when Type is Markdown.");

        return new TextObject
        {
            Type = _type.Value,
            Text = _text,
            Emoji = _emoji,
            Verbatim = _verbatim
        };
    }
}

================
File: Enums/BlockElementType.cs
================
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Hooki.Slack.Enums;

//ToDo: Refactor this in .NET 9 with new attribute: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonStringEnumMemberNameAttribute.cs
[JsonConverter(typeof(JsonStringEnumMemberConverter))]
public enum BlockElementType
{
    [EnumMember(Value = "button")]
    Button,

    [EnumMember(Value = "checkboxes")]
    Checkboxes,

    [EnumMember(Value = "datepicker")]
    DatePicker,

    [EnumMember(Value = "datetimepicker")]
    DatetimePicker,

    [EnumMember(Value = "email_text_input")]
    EmailInput,

    [EnumMember(Value = "file_input")]
    FileInput,

    [EnumMember(Value = "image")]
    Image,

    [EnumMember(Value = "multi_static_select")]
    MultiSelectMenu,

    [EnumMember(Value = "number_input")]
    NumberInput,

    [EnumMember(Value = "overflow")]
    OverflowMenu,

    [EnumMember(Value = "plain_text_input")]
    PlainTextInput,

    [EnumMember(Value = "radio_buttons")]
    RadioButtonGroup,

    [EnumMember(Value = "rich_text_input")]
    RichTextInput,

    [EnumMember(Value = "static_select")]
    SelectMenu,

    [EnumMember(Value = "timepicker")]
    TimePicker,

    [EnumMember(Value = "url_text_input")]
    UrlInput,

    [EnumMember(Value = "workflow_button")]
    WorkflowButton
}

================
File: Enums/BlockType.cs
================
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Hooki.Slack.Enums;

//ToDo: Refactor this in .NET 9 with new attribute: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonStringEnumMemberNameAttribute.cs
[JsonConverter(typeof(JsonStringEnumMemberConverter))]
public enum BlockType
{
    [EnumMember(Value = "actions")]
    ActionBlock,
    
    [EnumMember(Value = "context")]
    ContextBlock,
    
    [EnumMember(Value = "divider")]
    DividerBlock,
    
    [EnumMember(Value = "file")]
    FileBlock,
    
    [EnumMember(Value = "header")]
    HeaderBlock,
    
    [EnumMember(Value = "image")]
    ImageBlock,
    
    [EnumMember(Value = "input")]
    InputBlock,
    
    [EnumMember(Value = "rich_text")]
    RichTextBlock,
    
    [EnumMember(Value = "section")]
    SectionBlock,
    
    [EnumMember(Value = "video")]
    VideoBlock
}

================
File: Enums/RichTextBlockElementType.cs
================
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Hooki.Slack.Enums;

//ToDo: Refactor this in .NET 9 with new attribute: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonStringEnumMemberNameAttribute.cs
[JsonConverter(typeof(JsonStringEnumMemberConverter))]
public enum RichTextBlockElementType
{
    [EnumMember(Value = "rich_text_section")]
    RichTextSection,
    
    [EnumMember(Value = "rich_text_list")]
    RichTextList,
    
    [EnumMember(Value = "rich_text_preformatted")]
    RichTextPreformatted,
    
    [EnumMember(Value = "rich_text_quote")]
    RichTextQuote
}

================
File: Enums/RichTextElementType.cs
================
using System.Runtime.Serialization;

namespace Hooki.Slack.Enums;

public enum RichTextElementType
{
    [EnumMember(Value = "broadcast")]
    Broadcast,
    
    [EnumMember(Value = "color")]
    Color,
    
    [EnumMember(Value = "channel")]
    Channel,
    
    [EnumMember(Value = "date")]
    Date,
    
    [EnumMember(Value = "emoji")]
    Emoji,
    
    [EnumMember(Value = "link")]
    Link,
    
    [EnumMember(Value = "text")]
    Text,
    
    [EnumMember(Value = "user")]
    User,
    
    [EnumMember(Value = "usergroup")]
    UserGroup,
}

================
File: Enums/RichTextListStyleType.cs
================
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Hooki.Slack.Enums;

//ToDo: Refactor this in .NET 9 with new attribute: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonStringEnumMemberNameAttribute.cs
[JsonConverter(typeof(JsonStringEnumMemberConverter))]
public enum RichTextListStyleType
{
    [EnumMember(Value = "bullet")]
    Bullet,
    [EnumMember(Value = "ordered")]
    Ordered
}

================
File: Enums/TextObjectType.cs
================
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Hooki.Slack.Enums;

//ToDo: Refactor this in .NET 9 with new attribute: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonStringEnumMemberNameAttribute.cs
[JsonConverter(typeof(JsonStringEnumMemberConverter))]
public enum TextObjectType
{
    [EnumMember(Value = "plain_text")]
    PlainText,
    
    [EnumMember(Value = "mrkdwn")]
    Markdown
}

================
File: Enums/ViewObjectType.cs
================
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Hooki.Slack.Enums;

//ToDo: Refactor this in .NET 9 with new attribute: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonStringEnumMemberNameAttribute.cs
[JsonConverter(typeof(JsonStringEnumMemberConverter))]
public enum ViewObjectType
{
    [EnumMember(Value = "modal")]
    Modal,
    [EnumMember(Value = "home")]
    Home
}

================
File: Enums/WorkflowButtonElementStyle.cs
================
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace Hooki.Slack.Enums;

//ToDo: Refactor this in .NET 9 with new attribute: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonStringEnumMemberNameAttribute.cs
[JsonConverter(typeof(JsonStringEnumMemberConverter))]
public enum WorkflowButtonElementStyle
{
    /// <summary>
    /// Green styling used for affirmation or confirmation actions
    /// </summary>
    [EnumMember(Value = "primary")]
    Primary,
    
    /// <summary>
    /// Red styling used for destructive actions
    /// </summary>
    [EnumMember(Value = "danger")]
    Danger
}

================
File: JsonConverters/ActionBlockConverter.cs
================
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Hooki.Slack.Models.BlockElements;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.JsonConverters;

public class ActionBlockConverter : JsonConverter<BlockBase>
{
    private static readonly Dictionary<string, Type> TypeMap = new()
    {
        { "actions", typeof(ActionBlock) },
        { "context", typeof(ContextBlock) },
        { "divider", typeof(DividerBlock) },
        { "file", typeof(FileBlock) },
        { "header", typeof(HeaderBlock) },
        { "image", typeof(ImageBlock) },
        { "input", typeof(InputBlock) },
        { "rich_text", typeof(RichTextBlock) },
        { "section", typeof(SectionBlock) },
        { "video", typeof(VideoBlock) }
    };

    private static readonly Dictionary<string, Type> ElementTypeMap = new()
    {
        { "button", typeof(ButtonElement) },
        { "checkboxes", typeof(CheckboxElement) },
        { "datepicker", typeof(DatePickerElement) },
        { "datetimepicker", typeof(DateTimePickerElement) },
        { "multi_static_select", typeof(MultiSelectMenuElement) },
        { "overflow", typeof(OverflowMenuElement) },
        { "radio_buttons", typeof(RadioButtonGroupElement) },
        { "rich_text_input", typeof(RichTextInputElement) },
        { "static_select", typeof(SelectMenuElement) },
        { "timepicker", typeof(TimePickerElement) },
        { "workflow_button", typeof(WorkflowButtonElement) }
    };

    public override BlockBase Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
        {
            throw new JsonException("JSON object expected.");
        }

        using var jsonDoc = JsonDocument.ParseValue(ref reader);
        var root = jsonDoc.RootElement;

        if (!root.TryGetProperty("type", out var typeProperty))
        {
            throw new JsonException("Missing 'type' property");
        }

        var typeString = typeProperty.GetString()?.ToLower();
        if (!TypeMap.TryGetValue(typeString, out var blockType))
        {
            throw new JsonException($"Unknown block type: {typeString}");
        }

        var block = (BlockBase)Activator.CreateInstance(blockType);

        foreach (var property in blockType.GetProperties())
        {
            var jsonPropertyName = property.GetCustomAttribute<JsonPropertyNameAttribute>()?.Name ?? property.Name.ToLower();
            if (root.TryGetProperty(jsonPropertyName, out var element))
            {
                if (property.Name == "Elements" && blockType == typeof(ActionBlock))
                {
                    var elements = DeserializeActionBlockElements(element, options);
                    property.SetValue(block, elements);
                }
                else
                {
                    var value = JsonSerializer.Deserialize(element.GetRawText(), property.PropertyType, options);
                    property.SetValue(block, value);
                }
            }
        }

        return block;
    }

    public override void Write(Utf8JsonWriter writer, BlockBase value, JsonSerializerOptions options)
    {
        writer.WriteStartObject();

        foreach (var property in value.GetType().GetProperties())
        {
            var jsonPropertyName = property.GetCustomAttribute<JsonPropertyNameAttribute>()?.Name ?? property.Name.ToLower();
            var propertyValue = property.GetValue(value);

            if (propertyValue == null) continue;

            writer.WritePropertyName(jsonPropertyName);

            if (property.Name == "Elements" && value is ActionBlock)
            {
                SerializeActionBlockElements(writer, (List<IActionBlockElement>)propertyValue, options);
            }
            else
            {
                JsonSerializer.Serialize(writer, propertyValue, property.PropertyType, options);
            }
        }

        writer.WriteEndObject();
    }

    private List<IActionBlockElement> DeserializeActionBlockElements(JsonElement elementsProperty, JsonSerializerOptions options)
    {
        var elements = new List<IActionBlockElement>();

        foreach (var element in elementsProperty.EnumerateArray())
        {
            if (element.TryGetProperty("type", out var typeProperty))
            {
                var elementTypeString = typeProperty.GetString();
                if (ElementTypeMap.TryGetValue(elementTypeString, out var elementType))
                {
                    var blockElement = (IActionBlockElement)JsonSerializer.Deserialize(element.GetRawText(), elementType, options);
                    elements.Add(blockElement);
                }
                else
                {
                    throw new JsonException($"Unknown element type: {elementTypeString}");
                }
            }
        }

        if (elements.Count == 0)
        {
            throw new JsonException("ActionBlock must contain at least one element");
        }

        return elements;
    }

    private void SerializeActionBlockElements(Utf8JsonWriter writer, List<IActionBlockElement> elements, JsonSerializerOptions options)
    {
        writer.WriteStartArray();

        foreach (var element in elements)
        {
            JsonSerializer.Serialize(writer, element, element.GetType(), options);
        }

        writer.WriteEndArray();
    }
}

================
File: Models/BlockElements/BlockElementBase.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.BlockElements;

public class BlockElementBase
{
    [JsonPropertyName("action_id")] public string? ActionId { get; set; }
}

================
File: Models/BlockElements/ButtonElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#button
/// </summary>
public class ButtonElement : BlockElementBase, IActionBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.Button;

    [JsonPropertyName("text")] public required TextObject Text { get; set; }

    [JsonPropertyName("url")] public string? Url { get; set; }

    [JsonPropertyName("value")] public string? Value { get; set; }

    [JsonPropertyName("style")] public string? Style { get; set; }

    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }

    [JsonPropertyName("accessibility_label")] public string? AccessibilityLabel { get; set; }
}

================
File: Models/BlockElements/CheckboxElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#checkboxes
/// </summary>

public class CheckboxElement : BlockElementBase, IActionBlockElement, IInputBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.Checkboxes;

    [JsonPropertyName("options")] public required List<OptionObject> Options { get; set; }

    [JsonPropertyName("initial_options")] public List<OptionObject>? InitialOptions { get; set; }

    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }
}

================
File: Models/BlockElements/DatePickerElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#datepicker
/// </summary>
public class DatePickerElement : BlockElementBase, IActionBlockElement, IInputBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.DatePicker;

    /// <summary>
    /// Format YYYY-MM-DD
    /// </summary>
    [JsonPropertyName("initial_date")] public string? InitialDate { get; set; }
    
    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }

    /// <summary>
    /// When provided, the TextObject type should be "PlainText"
    /// </summary>
    [JsonPropertyName("placeholder")] public TextObject? Placeholder { get; set; }
}

================
File: Models/BlockElements/DateTimePickerElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#datetimepicker
/// </summary>
public class DateTimePickerElement : BlockElementBase, IActionBlockElement, IInputBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.DatetimePicker;

    /// <summary>
    /// Form as UNIX timestamp in seconds. Here is an example: 1628633820
    /// </summary>
    [JsonPropertyName("initial_date_time")] public int? InitialDateTime { get; set; }

    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }
}

================
File: Models/BlockElements/EmailInputElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#email
/// </summary>
public class EmailInputElement : BlockElementBase, IInputBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.EmailInput;

    [JsonPropertyName("initial_value")] public string? InitialValue { get; set; }

    [JsonPropertyName("dispatch_action_config")] public DispatchActionConfigurationObject? DispatchActionConfig { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }

    [JsonPropertyName("placeholder")] public TextObject? Placeholder { get; set; }
}

================
File: Models/BlockElements/FileInputElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#file_input
/// </summary>
public class FileInputElement : BlockElementBase, IInputBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.FileInput;

    [JsonPropertyName("filetypes")] public List<string>? FileTypes { get; set; }

    /// <summary>
    /// Supported file types: https://api.slack.com/types/file#types
    /// </summary>
    [JsonPropertyName("max_files")] public int? MaxFiles { get; set; }
}

================
File: Models/BlockElements/ImageElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#image
/// </summary>
public class ImageElement : BlockElementBase, IContextBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.Image;

    [JsonPropertyName("alt_text")] public required string AltText { get; set; }
    
    /// <summary>
    /// You must provide either an ImageUrl or SlackFile
    /// Maximum length is 3000 characters
    /// </summary>
    [JsonPropertyName("image_url")] public string? ImageUrl { get; set; }
    
    /// <summary>
    /// You must provide either an SlackFile or ImageUrl
    /// Refer to Discord's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#slack_file
    /// </summary>
    [JsonPropertyName("slack_file")] public SlackFileObject? SlackFile { get; set; }
}

================
File: Models/BlockElements/MultiSelectMenuElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#multi_select
/// </summary>
public class MultiSelectMenuElement : BlockElementBase, IActionBlockElement, IInputBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.MultiSelectMenu;

    [JsonPropertyName("placeholder")] public TextObject? Placeholder { get; set; }

    [JsonPropertyName("options")] public required OptionObject[] Options { get; set; }
    
    [JsonPropertyName("initial_options")] public OptionObject[]? InitialOptions { get; set; }

    [JsonPropertyName("option_groups")] public OptionGroupObject[]? OptionGroups { get; set; }
    
    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }
    
    [JsonPropertyName("max_selected_items")] public int? MaxSelectedItems { get; set; }
    
    // User list properties
    [JsonPropertyName("min_query_length")] public int? MinQueryLength { get; set; }
    
    [JsonPropertyName("initial_users")] public string[]? InitialUsers { get; set; }
    
    // Conversations list properties
    [JsonPropertyName("initial_conversations")] public string[]? InitialConversations { get; set; }
    [JsonPropertyName("default_to_current_conversation")] public bool? DefaultToCurrentConversation { get; set; }
    [JsonPropertyName("filter")] public ConversationFilterObject? Filter { get; set; }
    
    // Public channel list properties
    [JsonPropertyName("initial_channels")] public string[]? InitialChannels { get; set; }
}

================
File: Models/BlockElements/NumberInputElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#number
/// </summary>
public class NumberInputElement : BlockElementBase, IInputBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.NumberInput;

    [JsonPropertyName("is_decimal_allowed")]
    public required bool IsDecimalAllowed { get; set; }

    [JsonPropertyName("initial_value")]
    public string? InitialValue { get; set; }

    /// <summary>
    /// Cannot be greater than MaxValue
    /// </summary>
    [JsonPropertyName("min_value")]
    public string? MinValue { get; set; }

    /// <summary>
    /// Cannot be less than MinValue
    /// </summary>
    [JsonPropertyName("max_value")]
    public string? MaxValue { get; set; }

    [JsonPropertyName("dispatch_action_config")]
    public DispatchActionConfigurationObject? DispatchActionConfig { get; set; }

    [JsonPropertyName("focus_on_load")]
    public bool? FocusOnLoad { get; set; }

    [JsonPropertyName("placeholder")]
    public TextObject? Placeholder { get; set; }
}

================
File: Models/BlockElements/OverflowMenuElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#overflow
/// </summary>
public class OverflowMenuElement : BlockElementBase, IActionBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.OverflowMenu;

    [JsonPropertyName("options")] public required List<OptionObject> Options { get; set; }

    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }
}

================
File: Models/BlockElements/PlainTextInputElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#input
/// </summary>
public class PlainTextInputElement : BlockElementBase, IInputBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.PlainTextInput;

    [JsonPropertyName("initial_value")] public string? InitialValue { get; set; }

    [JsonPropertyName("multiline")] public bool? Multiline { get; set; }

    [JsonPropertyName("min_length")] public int? MinLength { get; set; }

    [JsonPropertyName("max_length")] public int? MaxLength { get; set; }

    [JsonPropertyName("dispatch_action_config")] public DispatchActionConfigurationObject? DispatchActionConfig { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }

    /// <summary>
    /// When provided, TextObject Type must be PlainText
    /// </summary>
    [JsonPropertyName("placeholder")] public TextObject? Placeholder { get; set; }
}

================
File: Models/BlockElements/RadioButtonGroupElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#radio
/// </summary>
public class RadioButtonGroupElement : BlockElementBase, IActionBlockElement, IInputBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.RadioButtonGroup;

    [JsonPropertyName("options")] public required OptionObject[] Options { get; set; }

    /// <summary>
    /// Must match one of the options within Options
    /// </summary>
    [JsonPropertyName("initial_option")] public OptionObject? InitialOption { get; set; }

    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }
}

================
File: Models/BlockElements/RichTextInputElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#rich_text_input
/// </summary>
public class RichTextInputElement : BlockElementBase, IActionBlockElement, IInputBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.RichTextInput;

    [JsonPropertyName("initial_value")]
    public RichTextBlock? InitialValue { get; set; }

    [JsonPropertyName("dispatch_action_config")]
    public DispatchActionConfigurationObject? DispatchActionConfig { get; set; }

    [JsonPropertyName("focus_on_load")]
    public bool? FocusOnLoad { get; set; }

    [JsonPropertyName("placeholder")]
    public TextObject? Placeholder { get; set; }
}

================
File: Models/BlockElements/SelectMenuElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#static_select
/// </summary>
public class SelectMenuElement : BlockElementBase, IActionBlockElement, IInputBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.SelectMenu;

    [JsonPropertyName("options")] public required OptionObject[] Options { get; set; }
    
    [JsonPropertyName("option_groups")] public OptionGroupObject[]? OptionGroups { get; set; }
    
    [JsonPropertyName("initial_option")] public OptionObject? InitialOption { get; set; }
    
    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }
    
    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }
    
    [JsonPropertyName("placeholder")] public TextObject? Placeholder { get; set; }
}

================
File: Models/BlockElements/TimePickerElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#timepicker
/// </summary>
public class TimePickerElement : BlockElementBase, IActionBlockElement, IInputBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.TimePicker;

    /// <summary>
    /// Format: HH:mm
    /// </summary>
    [JsonPropertyName("initial_time")] public string? InitialTime { get; set; }

    [JsonPropertyName("confirm")] public ConfirmationDialogObject? Confirm { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }

    [JsonPropertyName("placeholder")] public TextObject? Placeholder { get; set; }

    /// <summary>
    /// Format: IANA e.g. "America/Chicago"
    /// </summary>
    [JsonPropertyName("timezone")] public string? Timezone { get; set; }
}

================
File: Models/BlockElements/UrlInputElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#url
/// </summary>
public class UrlInputElement : BlockElementBase, IInputBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.UrlInput;

    [JsonPropertyName("initial_value")] public string? InitialValue { get; set; }

    [JsonPropertyName("dispatch_action_config")] public DispatchActionConfigurationObject? DispatchActionConfig { get; set; }

    [JsonPropertyName("focus_on_load")] public bool? FocusOnLoad { get; set; }

    [JsonPropertyName("placeholder")] public TextObject? Placeholder { get; set; }
}

================
File: Models/BlockElements/WorkflowButtonElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.BlockElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/block-elements#workflow_button
/// </summary>
public class WorkflowButtonElement : BlockElementBase, IActionBlockElement, ISectionBlockElement
{
    [JsonPropertyName("type")] public BlockElementType Type => BlockElementType.WorkflowButton;

    [JsonPropertyName("text")] public required TextObject Text { get; set; }

    [JsonPropertyName("workflow")] public required WorkflowObject Workflow { get; set; } 

    /// <summary>
    /// If you don't provide a value, default button style will be used
    /// </summary>
    [JsonPropertyName("style")] public WorkflowButtonElementStyle? Style { get; set; }

    [JsonPropertyName("accessibility_label")] public string? AccessibilityLabel { get; set; }
}

================
File: Models/Blocks/ActionBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#actions
/// </summary>

public class ActionBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.ActionBlock;

    [JsonPropertyName("elements")] public required List<IActionBlockElement> Elements { get; set; }
}

public interface IActionBlockElement { }

================
File: Models/Blocks/BlockBase.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.JsonConverters;

namespace Hooki.Slack.Models.Blocks;

[JsonConverter(typeof(ActionBlockConverter))]
public class BlockBase
{
    [JsonPropertyName("block_id")] public string? BlockId { get; set; }
}

================
File: Models/Blocks/ContextBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#context
/// </summary>
public class ContextBlock : BlockBase
{
    [JsonPropertyName("type")] public static BlockType Type => BlockType.ContextBlock;
    
    [JsonPropertyName("elements")] public required List<IContextBlockElement> Elements { get; set; }
}

public interface IContextBlockElement { }

================
File: Models/Blocks/DividerBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#divider
/// </summary>
public class DividerBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.DividerBlock;
}

================
File: Models/Blocks/FileBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#file
/// </summary>
public class FileBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.FileBlock;
    
    [JsonPropertyName("external_id")]
    public required string ExternalId { get; set; }
    
    [JsonPropertyName("source")]
    public required string Source { get; set; }
}

================
File: Models/Blocks/HeaderBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#header
/// </summary>
public class HeaderBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.HeaderBlock;
    
    [JsonPropertyName("text")] public required TextObject Text { get; set; }
}

================
File: Models/Blocks/ImageBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#image
/// </summary>
public class ImageBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.ImageBlock;
    
    [JsonPropertyName("alt_text")] public required TextObject AltText { get; set; }
    
    /// <summary>
    /// Must provide either ImageUrl or SlackFile
    /// </summary>
    [JsonPropertyName("image_url")] public string? ImageUrl { get; set; }
    
    /// <summary>
    /// Must provide either SlackFile or ImageUrl
    /// </summary>
    [JsonPropertyName("slack_file")] public SlackFileObject? SlackFile { get; set; }
    
    /// <summary>
    /// When provided, TextObject must be of type "PlainText"
    /// </summary>
    [JsonPropertyName("title")] public TextObject? Title { get; set; }
}

================
File: Models/Blocks/InputBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#input
/// </summary>
public class InputBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.InputBlock;
    
    /// <summary>
    /// TextObject must have type of "PlainText"
    /// </summary>
    [JsonPropertyName("label")] public required TextObject Label { get; set; }
    
    [JsonPropertyName("element")] public required IInputBlockElement Element { get; set; }
    
    [JsonPropertyName("dispatch_action")] public bool? DispatchAction { get; set; }
    
    /// <summary>
    /// TextObject must have type of "PlainText"
    /// </summary>
    [JsonPropertyName("hint")] public TextObject? Hint { get; set; }
    
    [JsonPropertyName("optional")] public bool? Optional { get; set; }
}

public interface IInputBlockElement { }

================
File: Models/Blocks/RichTextBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#rich_text
/// </summary>
public class RichTextBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.RichTextBlock;
    
    [JsonPropertyName("elements")] public required List<IRichTextBlockElement> Elements { get; set; }
}

public interface IRichTextBlockElement { }

public interface IRichTextElement { }

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#rich_text_section
/// </summary>
public class RichTextSection : IRichTextBlockElement
{
    [JsonPropertyName("type")] public const RichTextBlockElementType Type = RichTextBlockElementType.RichTextSection;
    
    [JsonPropertyName("elements")] public required IRichTextElement[] Elements { get; set; }
}

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#rich_text_list
/// </summary>
public class RichTextList : IRichTextBlockElement
{
    [JsonPropertyName("type")] public const RichTextBlockElementType Type = RichTextBlockElementType.RichTextList;
    
    [JsonPropertyName("style")] public required RichTextListStyleType Style { get; set; }
    
    [JsonPropertyName("elements")] public required IRichTextElement[] Elements { get; set; }
    
    [JsonPropertyName("indent")] public int? Indent { get; set; }
    
    [JsonPropertyName("offset")] public int? Offset { get; set; }
    
    [JsonPropertyName("border")] public int? Border { get; set; }
}

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#rich_text_preformatted
/// </summary>
public class RichTextPreformatted : IRichTextBlockElement
{
    [JsonPropertyName("type")] public const RichTextBlockElementType Type = RichTextBlockElementType.RichTextPreformatted;
    
    [JsonPropertyName("elements")] public required IRichTextElement[] Elements { get; set; }
    
    [JsonPropertyName("border")] public int? Border { get; set; }
}

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#rich_text_quote
/// </summary>
public class RichTextQuote : IRichTextBlockElement
{
    [JsonPropertyName("type")] public const RichTextBlockElementType Type = RichTextBlockElementType.RichTextQuote;
    
    [JsonPropertyName("elements")] public required IRichTextElement[] Elements { get; set; }
    
    [JsonPropertyName("border")] public int? Border { get; set; }
}

================
File: Models/Blocks/SectionBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#section
/// </summary>
public class SectionBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.SectionBlock;
    
    /// <summary>
    /// TextObject must have type of "PlainText"
    /// This is a preferred field
    /// </summary>
    [JsonPropertyName("text")] public TextObject? Text { get; set; }
    
    /// <summary>
    /// This is a maybe field
    /// Required if Text isn't provided
    /// </summary>
    [JsonPropertyName("fields")] public TextObject[]? Fields { get; set; }
    
    [JsonPropertyName("accessory")] public ISectionBlockElement? Accessory { get; set; }
    
    [JsonPropertyName("expand")] public bool? Expand { get; set; }
}

public interface ISectionBlockElement { }

================
File: Models/Blocks/VideoBlock.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.Blocks;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#video
/// </summary>
public class VideoBlock : BlockBase
{
    [JsonPropertyName("type")] public BlockType Type => BlockType.VideoBlock;
    
    [JsonPropertyName("alt_text")] public required string AltText { get; set; }
    
    [JsonPropertyName("author_name")] public string? AuthorName { get; set; }
    
    /// <summary>
    /// TextObject must have type of "PlainText"
    /// </summary>
    [JsonPropertyName("description")] public required TextObject Description { get; set; }
    
    [JsonPropertyName("provider_icon_url")] public string? ProviderIconUrl { get; set; }
    
    [JsonPropertyName("provider_name")] public string? ProviderName { get; set; }
    
    /// <summary>
    /// TextObject must have type of "PlainText"
    /// </summary>
    [JsonPropertyName("title")] public TextObject? Title { get; set; }
    
    /// <summary>
    /// When provided, the url must be HTTPS
    /// </summary>
    
    [JsonPropertyName("title_url")] public string? TitleUrl { get; set; }
    
    [JsonPropertyName("thumbnail_url")] public required string ThumbnailUrl { get; set; }
    
    [JsonPropertyName("video_url")] public required string VideoUrl { get; set; }
}

================
File: Models/CompositionObjects/ConfirmationDialogObject.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#confirm
/// </summary>
public class ConfirmationDialogObject
{
    [JsonPropertyName("title")] public required TextObject Title { get; set; }
    
    [JsonPropertyName("text")] public required TextObject Text { get; set; }
    
    [JsonPropertyName("confirm")] public required TextObject Confirm { get; set; }
    
    [JsonPropertyName("deny")] public required TextObject Deny { get; set; }
    
    [JsonPropertyName("style")] public string? Style { get; set; }
}

================
File: Models/CompositionObjects/ConversationFilterObject.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Please note that while none of the fields above are individually required, you must supply at least one of these fields.
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#filter_conversations
/// </summary>
public class ConversationFilterObject
{
    [JsonPropertyName("include")] public string[]? Include { get; set; }
    
    [JsonPropertyName("exclude_external_shared_channels")] public bool? ExcludeExternalSharedChannels { get; set; }
    
    [JsonPropertyName("exclude_bot_users")] public bool? ExcludeBotUsers { get; set; }
}

================
File: Models/CompositionObjects/DispatchActionConfigurationObject.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#dispatch_action_config
/// </summary>
public class DispatchActionConfigurationObject
{
    [JsonPropertyName("trigger_actions_on")] public string[]? TriggerActionsOn { get; set; }
}

================
File: Models/CompositionObjects/OptionGroupObject.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#option_group
/// </summary>
public class OptionGroupObject
{
    /// <summary>
    /// TextObject type should be "PlainText"
    /// </summary>
    [JsonPropertyName("label")] public required TextObject Label { get; set; }
    
    [JsonPropertyName("options")] public required OptionObject[] Options { get; set; }
}

================
File: Models/CompositionObjects/OptionObject.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#option
/// </summary>
public class OptionObject
{
    [JsonPropertyName("text")] public required TextObject Text { get; set; }
    
    [JsonPropertyName("value")] public required string Value { get; set; }
    
    /// <summary>
    /// When provided, the TextObject type should be "PlainText"
    /// </summary>
    [JsonPropertyName("description")] public TextObject? Description { get; set; }
    
    [JsonPropertyName("url")] public string? Url { get; set; }
}

================
File: Models/CompositionObjects/SlackFileObject.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#slack_file
/// </summary>
public class SlackFileObject
{
    [JsonPropertyName("url")] public string? Url { get; set; }
    
    [JsonPropertyName("id")] public string? Id { get; set; }
}

================
File: Models/CompositionObjects/TextObject.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#text
/// </summary>
public class TextObject : IContextBlockElement
{
    [JsonPropertyName("type")] public required TextObjectType Type { get; set; }
    
    [JsonPropertyName("text")] public required string Text { get; set; }
    
    /// <summary>
    /// This field is only usable when Type is plain_text
    /// </summary>
    [JsonPropertyName("emoji")] public bool? Emoji { get; set; }
    
    /// <summary>
    /// This field is only usable when Type is mrkdwn
    /// </summary>
    [JsonPropertyName("verbatim")] public bool? Verbatim { get; set; }
}

================
File: Models/CompositionObjects/TriggerObject.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#trigger
/// </summary>
public class TriggerObject
{
    /// <summary>
    /// Url must be a valid link trigger url. Refer to Slack's documentation for more details: https://api.slack.com/automation/triggers/link
    /// </summary>
    [JsonPropertyName("url")] public required string Url { get; set; }
    
    [JsonPropertyName("customizable_input_parameters")] public CustomizableInputParameter[]? CustomizableInputParameters { get; set; }
}

/// <summary>
/// The values used for these customizable_input_parameters may be visible client-side to end users.
/// You should not share sensitive information or secrets via these input parameters.
/// </summary>
public class CustomizableInputParameter
{
    public required string Name { get; set; }
    public required string Value { get; set; }
}

================
File: Models/CompositionObjects/WorkflowObject.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.CompositionObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#workflow
/// </summary>
public class WorkflowObject
{
    [JsonPropertyName("trigger")] public required TriggerObject Trigger { get; set; }
}

================
File: Models/RichTextElements/AdvancedTextStyle.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.RichTextElements;

public class AdvancedTextStyle
{
    [JsonPropertyName("bold")] public bool? Bold { get; set; }
    
    [JsonPropertyName("italic")] public bool? Italic { get; set; }
    
    [JsonPropertyName("strike")] public bool? Strike { get; set; }
    
    [JsonPropertyName("highlight")] public bool? Highlight { get; set; }
    
    [JsonPropertyName("client_highlight")] public bool? ClientHighlight { get; set; }
    
    [JsonPropertyName("unlink")] public bool? Unlink { get; set; }
}

================
File: Models/RichTextElements/BasicTextStyle.cs
================
using System.Text.Json.Serialization;

namespace Hooki.Slack.Models.RichTextElements;

public class BasicTextStyle
{
    [JsonPropertyName("Bold")] public bool? Bold { get; set; }
    
    [JsonPropertyName("italic")] public bool? Italic { get; set; }
    
    [JsonPropertyName("strike")] public bool? Strike { get; set; }
    
    [JsonPropertyName("code")] public bool? Code { get; set; }
}

================
File: Models/RichTextElements/BroadcastElement.cs
================
using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class BroadcastElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.Broadcast;
    
    [JsonPropertyName("range")] public required BroadcastRangeType Range { get; set; }
}

//ToDo: Refactor this in .NET 9 with new attribute: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonStringEnumMemberNameAttribute.cs
[JsonConverter(typeof(JsonStringEnumMemberConverter))]
public enum BroadcastRangeType
{
    [EnumMember(Value = "here")]
    Here,
    
    [EnumMember(Value = "channel")]
    Channel,
    
    [EnumMember(Value = "everyone")]
    Everyone
}

================
File: Models/RichTextElements/ChannelElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class ChannelElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.Channel;
    
    [JsonPropertyName("channel_id")] public required string ChannelId { get; set; }
    
    [JsonPropertyName("style")] public AdvancedTextStyle? Style { get; set; }
}

================
File: Models/RichTextElements/ColorElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class ColorElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.Color;
    
    /// <summary>
    /// The hex value for the color
    /// </summary>
    [JsonPropertyName("value")] public required string Value { get; set; }
}

================
File: Models/RichTextElements/DateElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class DateElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.Date;
    
    /// <summary>
    /// A Unix timestamp for the date to be displayed in seconds
    /// </summary>
    [JsonPropertyName("timestamp")] public required int Timestamp { get; set; }
    
    /// <summary>
    /// A template string containing curly-brace-enclosed tokens to substitute your provided timestamp
    /// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#color-element-type
    /// </summary>
    [JsonPropertyName("format")] public required string Format { get; set; }
}

================
File: Models/RichTextElements/EmojiElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class EmojiElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.Emoji;
    
    /// <summary>
    /// The name of the emoji; i.e. "wave" or "wave::skin-tone-2"
    /// </summary>
    [JsonPropertyName("name")] public required string Name { get; set; }
    
    /// <summary>
    /// Represents the unicode code point of the emoji, where applicable
    /// </summary>
    [JsonPropertyName("unicode")] public string? Unicode { get; set; }
}

================
File: Models/RichTextElements/LinkElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class LinkElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.Link;
    
    [JsonPropertyName("url")] public required string Url { get; set; }
    
    [JsonPropertyName("text")] public string? Text { get; set; }
    
    [JsonPropertyName("unsafe")] public bool? Unsafe { get; set; }
    
    [JsonPropertyName("style")] public required BasicTextStyle Style { get; set; }
}

================
File: Models/RichTextElements/TextElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class TextElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.Text;
    
    [JsonPropertyName("text")] public required string Text { get; set; }
    
    [JsonPropertyName("style")] public BasicTextStyle? Style { get; set; }
}

================
File: Models/RichTextElements/UserElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class UserElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.User;
     
    [JsonPropertyName("user_id")] public required string UserId { get; set; }
    
    [JsonPropertyName("style")] public AdvancedTextStyle? Style { get; set; }
}

================
File: Models/RichTextElements/UserGroupElement.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.RichTextElements;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/blocks#element-types
/// </summary>
public class UserGroupElement : IRichTextElement
{
    [JsonPropertyName("type")] public RichTextElementType Type => RichTextElementType.UserGroup;
    
    [JsonPropertyName("usergroup_id")] public required string UserGroupId { get; set; }
    
    [JsonPropertyName("style")] public AdvancedTextStyle? Style { get; set; }
}

================
File: Models/ViewObjects/HomeTab.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models.ViewObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/block-kit/composition-objects#confirm
/// </summary>
public class HomeTab
{
    [JsonPropertyName("type")] public static ViewObjectType Type => ViewObjectType.Home;
    
    [JsonPropertyName("blocks")] public required BlockBase[] Blocks { get; set; }
    
    [JsonPropertyName("private_metadata")] public string? PrivateMetadata { get; set; }
    
    [JsonPropertyName("callback_id")] public string? CallbackId { get; set; }
    
    [JsonPropertyName("external_id")] public string? ExternalId { get; set; }
}

================
File: Models/ViewObjects/Modal.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Enums;
using Hooki.Slack.Models.Blocks;
using Hooki.Slack.Models.CompositionObjects;

namespace Hooki.Slack.Models.ViewObjects;

/// <summary>
/// Refer to Slack's documentation for more details: https://api.slack.com/reference/surfaces/views#modal
/// </summary>
public class Modal
{
    [JsonPropertyName("type")] public static ViewObjectType Type => ViewObjectType.Modal;

    [JsonPropertyName("title")] public required TextObject Title { get; set; }
    
    [JsonPropertyName("blocks")] public required BlockBase[] Blocks { get; set; }
    
    /// <summary>
    /// When provided, TextObject must be of type PlainText
    /// </summary>
    [JsonPropertyName("close")] public TextObject? Close { get; set; }
    
    /// <summary>
    /// When provided, TextObject must be of type PlainText
    /// </summary>
    [JsonPropertyName("submit")] public TextObject? Submit { get; set; }
    
    [JsonPropertyName("private_metadata")] public string? PrivateMetadata { get; set; }
    
    [JsonPropertyName("callback_id")] public string? CallBackId { get; set; }
    
    [JsonPropertyName("clear_on_close")] public bool? ClearOnClose { get; set; }
    
    [JsonPropertyName("notify_on_close")] public bool? NotifyOnClose { get; set; }
    
    [JsonPropertyName("external_id")] public string? ExternalId { get; set; }
    
    [JsonPropertyName("submit_disabled")] public bool? SubmitDisabled { get; set; }
}

================
File: Models/SlackWebhookPayload.cs
================
using System.Text.Json.Serialization;
using Hooki.Slack.Models.Blocks;

namespace Hooki.Slack.Models;

public class SlackWebhookPayload
{
    [JsonPropertyName("blocks")] public required List<BlockBase> Blocks { get; set; }
}
